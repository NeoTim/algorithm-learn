{"./":{"url":"./","title":"前言","keywords":"","body":"算法学习笔记 学习资料： 算法 第四版 普林斯顿算法课程 Part I Part II https://algs4.cs.princeton.edu/home/ "},"union-find/":{"url":"union-find/","title":"并查集","keywords":"","body":"并查集算法 动态连通性 算法实现 完整实现 动态连通性 给定一些对象，这些对象中的某些对象存在 连通 的关系，这里我们假设 连通 关系是一种等价 (equivalence) 关系： 自反性 (Reflexive): p 和 p 是相连的 对称性 (Symmetric): 如果 p 和 q 相连，那么 q 和 p 也是相连的 传递性 (Transitive): 如何 p 和 q 相连并且 q 和 r 也是相连的，那么 p 和 r 也是相连的。 等价关系可以将对象分为多个等价类。在这里，当且仅当两个对象相连时它们才属于同一个等价类。在动态连通性问题中，对于给定的两点 p 和 q，我们需要判断 p 和 q 是否相连，同时对象之间的连通关系会动态的发生变化。 算法实现 下面是算法的 API： 其中 connected 和 count 实现比较简单： public boolean connected(int p, int q) { return find(p) == find(q); } public int count() { return count; } 对于合并和查找这里主要记录一下 weighted quick-union 算法。在该算法中，使用一个数组 sites 来存储点，通过模拟森林来表示连通关系，森林中的每棵树都表示一个连通分量。对于索引 i，如果 sites[i] == i 那么点 i 就是某个树的根节点，如果 sites[i] != i，那么表明这是一个子节点，该节点中的值就是它父节点的索引，通过父节点，我们可以递归的向上直到找到最终的根节点。下面是实现 find 和 union 的方式： 对于 find(int p)，判断当前点 p 是否为根节点，如果是返回 p，否则递归的往上找。在向上找的过程中，进行路径压缩，也就是将 p 指向它的祖父节点。 对于 union(int p, int q)，首先找到 p 和 q 对应的根节点，判断两者是否相同。如果不同则进行合并，合并的依赖的将小树合并到大树上(这里用一个专门的数组记录了每棵树的大小)。 下面是算法实现 /** * Returns the component identifier for the component containing site {@code p}. * * @param p the integer representing one site * @return the component identifier for the component containing site {@code p} * @throws IllegalArgumentException unless {@code 0 完整实现 下面是算法的完整实现， 源码地址： /****************************************************************************** * Compilation: javac UF.java * Execution: java UF union–find data type * (also known as the disjoint-sets data type). * It supports the union and find operations, * along with a connected operation for determining whether * two sites are in the same component and a count operation that * returns the total number of components. * * The union–find data type models connectivity among a set of n * sites, named 0 through n–1. * The is-connected-to relation must be an * equivalence relation: * * Reflexive: p is connected to p. * Symmetric: If p is connected to q, * then q is connected to p. * Transitive: If p is connected to q * and q is connected to r, then * p is connected to r. * * * An equivalence relation partitions the sites into * equivalence classes (or components). In this case, * two sites are in the same component if and only if they are connected. * Both sites and components are identified with integers between 0 and * n–1. * Initially, there are n components, with each site in its * own component. The component identifier of a component * (also known as the root, canonical element, leader, * or set representative) is one of the sites in the component: * two sites have the same component identifier if and only if they are * in the same component. * * union(p, q) adds a * connection between the two sites p and q. * If p and q are in different components, * then it replaces * these two components with a new component that is the union of * the two. * find(p) returns the component * identifier of the component containing p. * connected(p, q) * returns true if both p and q * are in the same component, and false otherwise. * count() returns the number of components. * * * The component identifier of a component can change * only when the component itself changes during a call to * union—it cannot change during a call * to find, connected, or count. * * This implementation uses weighted quick union by rank with path compression * by halving. * Initializing a data structure with n sites takes linear time. * Afterwards, the union, find, and connected * operations take logarithmic time (in the worst case) and the * count operation takes constant time. * Moreover, the amortized time per union, find, * and connected operation has inverse Ackermann complexity. * For alternate implementations of the same API, see * {@link QuickUnionUF}, {@link QuickFindUF}, and {@link WeightedQuickUnionUF}. * * * For additional documentation, see Section 1.5 of * Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. * * @author Robert Sedgewick * @author Kevin Wayne */ public class UF { private int[] parent; // parent[i] = parent of i private byte[] rank; // rank[i] = rank of subtree rooted at i (never more than 31) private int count; // number of components /** * Initializes an empty union–find data structure with {@code n} sites * {@code 0} through {@code n-1}. Each site is initially in its own * component. * * @param n the number of sites * @throws IllegalArgumentException if {@code n = n) { throw new IllegalArgumentException(\"index \" + p + \" is not between 0 and \" + (n-1)); } } /** * Reads in a an integer {@code n} and a sequence of pairs of integers * (between {@code 0} and {@code n-1}) from standard input, where each integer * in the pair represents some site; * if the sites are in different components, merge the two components * and print the pair to standard output. * * @param args the command-line arguments */ public static void main(String[] args) { int n = StdIn.readInt(); UF uf = new UF(n); while (!StdIn.isEmpty()) { int p = StdIn.readInt(); int q = StdIn.readInt(); if (uf.connected(p, q)) continue; uf.union(p, q); StdOut.println(p + \" \" + q); } StdOut.println(uf.count() + \" components\"); } } /****************************************************************************** * Copyright 2002-2016, Robert Sedgewick and Kevin Wayne. * * This file is part of algs4.jar, which accompanies the textbook * * Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne, * Addison-Wesley Professional, 2011, ISBN 0-321-57351-X. * http://algs4.cs.princeton.edu * * * algs4.jar is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * algs4.jar is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with algs4.jar. If not, see http://www.gnu.org/licenses. ******************************************************************************/ "}}